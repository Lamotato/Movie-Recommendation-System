# 电影推荐系统设计方案

## 一、需求澄清

### 1.1 核心业务需求
- **用户角色**：普通用户、管理员、影院人员
- **核心功能**：电影管理、在线选座、订单管理、电影推荐（重点）
- **推荐场景**：首页"猜你喜欢"电影推荐

### 1.2 技术栈确认
**后端**：Spring Boot 3 + JDK 21 + MyBatis + MySQL
**前端**：Vue3 + Element Plus
**推荐系统**：采用渐进式架构
- **第一阶段**（MVP）：MySQL + Redis + 简化推荐算法
- **第二阶段**（扩展）：引入Spark、MongoDB、ElasticSearch等大数据组件

## 二、推荐算法方案设计

### 2.1 混合推荐策略（推荐方案）

采用**多策略融合的混合推荐算法**，而非单一的"推荐树算法"：

#### 策略1：基于用户画像的决策树策略选择
```
用户特征判断
├── 新用户（行为数据 < 5条）
│   └── 使用：兴趣标签推荐 + 热门推荐
├── 轻度用户（行为数据 5-20条）
│   └── 使用：协同过滤（基于用户相似度）+ 热门推荐
└── 重度用户（行为数据 > 20条）
    └── 使用：ALS隐语义模型 + 实时推荐 + 热门推荐补充
```

#### 策略2：多算法融合加权
- **协同过滤推荐**（权重40%）：基于用户相似度和电影相似度
- **内容推荐**（权重30%）：基于电影类型、标签、演员、导演
- **热门推荐**（权重20%）：基于评分、票房、观看量
- **实时推荐**（权重10%）：基于最近浏览、评分行为

#### 策略3：冷启动处理
- **新用户**：基于注册时的兴趣标签推荐
- **新电影**：基于类型、导演、演员推荐相似电影

### 2.2 推荐算法实现方案对比

| 方案 | 优点 | 缺点 | 适用场景 | 成本 |
|------|------|------|----------|------|
| **方案A：简化版（推荐）**<br/>MySQL+Redis+内存计算 | 1. 实现简单快速<br/>2. 无需大数据组件<br/>3. 响应速度快<br/>4. 易于维护 | 1. 数据量受限（<100万用户）<br/>2. 算法复杂度有限 | MVP阶段、中小型系统 | 低 |
| **方案B：完整版**<br/>Spark+Hive+MongoDB | 1. 支持海量数据<br/>2. 算法丰富<br/>3. 可扩展性强 | 1. 架构复杂<br/>2. 运维成本高<br/>3. 开发周期长 | 大型系统、百万级用户 | 高 |
| **方案C：混合版**<br/>MySQL+Redis+定时Spark任务 | 1. 平衡性能与复杂度<br/>2. 支持离线训练<br/>3. 实时推荐快速 | 1. 需要Spark环境<br/>2. 数据同步复杂 | 中大型系统 | 中 |

**推荐选择**：采用**方案A（简化版）**作为第一阶段，后续可平滑升级到方案C。

## 三、数据库设计

### 3.1 核心表结构设计

#### 用户相关表
1. **user** - 用户表
2. **admin** - 管理员表（已存在）
3. **cinema** - 影院表
4. **user_interest_tags** - 用户兴趣标签表

#### 电影相关表
5. **movie** - 电影信息表
6. **movie_type** - 电影类型表
7. **movie_type_relation** - 电影类型关联表（多对多）
8. **movie_tag** - 电影标签表
9. **movie_tag_relation** - 电影标签关联表
10. **movie_cast** - 演职人员表
11. **movie_rating** - 电影评分表

#### 影院相关表
12. **cinema_room** - 影院房间表
13. **screening** - 放映场次表
14. **seat** - 座位表
15. **order** - 订单表
16. **order_detail** - 订单明细表

#### 推荐相关表
17. **user_behavior** - 用户行为表（浏览、评分、收藏等）
18. **recommendation_result** - 推荐结果表（缓存推荐列表）
19. **recommendation_evaluation** - 推荐效果评估表

#### 其他表
20. **announcement** - 公告表
21. **user_favorite** - 用户收藏表

### 3.2 推荐算法所需的关键字段

**user_behavior表**：记录用户行为，用于推荐计算
- 行为类型：browse（浏览）、rate（评分）、favorite（收藏）、comment（评论）、search（搜索）
- 行为时间：用于时间衰减计算
- 关联对象：movie_id、search_keyword等

**recommendation_result表**：存储预计算的推荐结果
- 用户ID、推荐电影列表（JSON）、推荐策略、生成时间、过期时间

## 四、系统架构设计

### 4.1 分层架构
```
Controller层（API接口）
    ↓
Service层（业务逻辑）
    ├── UserService（用户管理）
    ├── MovieService（电影管理）
    ├── RecommendationService（推荐服务）⭐
    ├── OrderService（订单管理）
    └── BehaviorService（行为采集）
    ↓
Mapper层（数据访问）
    ↓
MySQL数据库
```

### 4.2 推荐服务架构
```
RecommendationService
├── StrategySelector（策略选择器）
│   └── 根据用户特征选择推荐策略
├── CollaborativeFiltering（协同过滤）
│   └── 基于用户相似度和电影相似度
├── ContentBasedRecommendation（内容推荐）
│   └── 基于电影特征相似度
├── PopularRecommendation（热门推荐）
│   └── 基于评分、票房、观看量
├── RealTimeRecommendation（实时推荐）
│   └── 基于最近行为
└── RecommendationMerger（推荐融合器）
    └── 多策略加权融合
```

## 五、执行计划（敏捷迭代）

### 迭代1：基础框架搭建（1周）
**目标**：完成数据库设计和基础CRUD功能

**任务**：
1. ✅ 数据库表结构设计
2. 创建所有Entity实体类
3. 创建基础Mapper接口
4. 实现用户注册、登录功能
5. 实现管理员基础CRUD

### 迭代2：电影管理模块（1周）
**目标**：完成电影数据的增删改查

**任务**：
1. 电影类型管理
2. 电影信息管理（支持多类型关联）
3. 演职人员管理
4. 电影标签管理
5. 数据校验功能

### 迭代3：影院与订单模块（1周）
**目标**：完成影院、选座、订单功能

**任务**：
1. 影院管理
2. 房间管理
3. 放映场次管理
4. 在线选座功能
5. 订单管理

### 迭代4：用户行为采集（3天）
**目标**：记录用户行为数据

**任务**：
1. 行为数据采集接口
2. 行为数据存储
3. 行为数据统计

### 迭代5：推荐引擎核心（2周）⭐
**目标**：实现混合推荐算法

**任务**：
1. 用户画像计算（新用户/轻度/重度）
2. 协同过滤算法实现
3. 内容推荐算法实现
4. 热门推荐算法实现
5. 实时推荐算法实现
6. 推荐结果融合
7. Redis缓存推荐结果

### 迭代6：推荐效果评估（1周）
**目标**：评估推荐效果

**任务**：
1. 准确率、召回率计算
2. 用户满意度统计
3. 推荐多样性计算
4. 可视化报表

### 迭代7：前端开发（2周）
**目标**：完成前端页面

**任务**：
1. 用户端首页（含推荐）
2. 电影列表、详情页
3. 选座购票页面
4. 订单管理页面
5. 管理员后台

## 六、技术难点与解决方案

### 6.1 推荐算法性能优化
**问题**：协同过滤计算量大，响应慢
**方案**：
- 预计算推荐结果，存储到Redis
- 使用增量更新，只计算变化部分
- 限制推荐列表长度（Top-N）

### 6.2 冷启动问题
**问题**：新用户、新电影无历史数据
**方案**：
- 新用户：基于注册兴趣标签推荐
- 新电影：基于类型、演员推荐相似电影
- 热门推荐兜底

### 6.3 实时性要求
**问题**：用户行为后需要快速更新推荐
**方案**：
- 实时推荐单独计算，不依赖离线模型
- 使用Redis存储最近行为
- 异步更新推荐结果

## 七、后续扩展方向

1. **引入Spark**：当用户量>10万时，使用Spark进行离线模型训练
2. **引入ElasticSearch**：实现全文搜索功能
3. **引入MongoDB**：存储非结构化推荐数据
4. **A/B测试**：对比不同推荐策略效果
5. **深度学习**：引入神经网络推荐模型
