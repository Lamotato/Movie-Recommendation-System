# 混合推荐算法设计文档

## 一、算法概述

### 1.1 设计目标
- **准确性**：推荐用户真正感兴趣的电影
- **多样性**：避免推荐结果过于单一
- **实时性**：快速响应用户请求（<200ms）
- **可扩展性**：支持后续算法优化和扩展

### 1.2 推荐策略选择树（决策树）

```
用户特征分析
│
├─ 新用户（行为数据 < 5条）
│   ├─ 有注册兴趣标签
│   │   └─ 策略：内容推荐（基于标签） + 热门推荐（权重：70% + 30%）
│   └─ 无注册兴趣标签
│       └─ 策略：热门推荐（100%）
│
├─ 轻度用户（行为数据 5-20条）
│   └─ 策略：协同过滤（用户相似度） + 热门推荐（权重：60% + 40%）
│
└─ 重度用户（行为数据 > 20条）
    ├─ 有评分数据（>= 3条）
    │   └─ 策略：协同过滤（ALS隐语义） + 实时推荐 + 热门推荐（权重：50% + 30% + 20%）
    └─ 无评分数据（仅浏览）
        └─ 策略：协同过滤（浏览相似度） + 实时推荐 + 热门推荐（权重：50% + 30% + 20%）
```

## 二、核心推荐算法

### 2.1 协同过滤推荐（Collaborative Filtering）

#### 2.1.1 基于用户的协同过滤（User-Based CF）
**原理**：找到与目标用户兴趣相似的用户，推荐这些用户喜欢的电影

**相似度计算**（余弦相似度）：
```
sim(u1, u2) = cos(θ) = (u1 · u2) / (||u1|| × ||u2||)
```

**实现步骤**：
1. 构建用户-电影评分矩阵
2. 计算用户相似度（基于共同评分的电影）
3. 找到Top-K相似用户
4. 预测目标用户对未评分电影的评分
5. 返回Top-N推荐电影

**SQL实现示例**：
```sql
-- 1. 计算用户相似度（基于共同评分的电影）
SELECT 
    u1.user_id as user1,
    u2.user_id as user2,
    SUM(u1.rating * u2.rating) / (SQRT(SUM(u1.rating * u1.rating)) * SQRT(SUM(u2.rating * u2.rating))) as similarity
FROM movie_rating u1
JOIN movie_rating u2 ON u1.movie_id = u2.movie_id AND u1.user_id < u2.user_id
WHERE u1.user_id = ? -- 目标用户
GROUP BY u1.user_id, u2.user_id
HAVING similarity > 0.3
ORDER BY similarity DESC
LIMIT 20;

-- 2. 预测评分并推荐
SELECT 
    m.movie_id,
    SUM(sim.similarity * r.rating) / SUM(ABS(sim.similarity)) as predicted_rating
FROM (
    -- 相似用户列表
    SELECT user2 as similar_user, similarity FROM user_similarity WHERE user1 = ?
) sim
JOIN movie_rating r ON r.user_id = sim.similar_user
LEFT JOIN movie_rating target ON target.user_id = ? AND target.movie_id = r.movie_id
WHERE target.movie_id IS NULL -- 排除已评分的电影
GROUP BY m.movie_id
ORDER BY predicted_rating DESC
LIMIT 20;
```

#### 2.1.2 基于物品的协同过滤（Item-Based CF）
**原理**：找到与用户已评分电影相似的其他电影

**相似度计算**：
```
sim(m1, m2) = cos(θ) = (m1 · m2) / (||m1|| × ||m2||)
```

**实现步骤**：
1. 构建电影-用户评分矩阵
2. 计算电影相似度（基于共同评分的用户）
3. 根据用户已评分电影，推荐相似电影

### 2.2 内容推荐（Content-Based Recommendation）

**原理**：基于电影的特征（类型、标签、演员、导演）推荐相似电影

**特征向量构建**：
- 电影类型（One-Hot编码）
- 电影标签（TF-IDF权重）
- 演员、导演（One-Hot编码）

**相似度计算**（余弦相似度）：
```
sim(m1, m2) = cos(θ) = (m1 · m2) / (||m1|| × ||m2||)
```

**实现步骤**：
1. 构建电影特征向量
2. 计算电影间相似度
3. 根据用户历史行为（浏览、评分、收藏）的电影，推荐相似电影

**SQL实现示例**：
```sql
-- 基于用户收藏/评分的电影，推荐相似电影
SELECT 
    m2.id as movie_id,
    COUNT(DISTINCT mtr1.tag_id) as common_tags,
    COUNT(DISTINCT mtr2.type_id) as common_types
FROM movie_rating mr
JOIN movie m1 ON m1.id = mr.movie_id
JOIN movie_tag_relation mtr1 ON mtr1.movie_id = m1.id
JOIN movie_tag_relation mtr2 ON mtr2.tag_id = mtr1.tag_id AND mtr2.movie_id != m1.id
JOIN movie m2 ON m2.id = mtr2.movie_id
LEFT JOIN movie_rating mr2 ON mr2.user_id = mr.user_id AND mr2.movie_id = m2.id
WHERE mr.user_id = ? 
  AND mr2.id IS NULL -- 排除已评分的电影
GROUP BY m2.id
ORDER BY common_tags DESC, common_types DESC
LIMIT 20;
```

### 2.3 热门推荐（Popular Recommendation）

**原理**：推荐当前最受欢迎的电影

**评分公式**：
```
popularity_score = (rating × 0.4) + (box_office_normalized × 0.3) + (view_count_normalized × 0.2) + (favorite_count_normalized × 0.1)
```

**实现步骤**：
1. 计算各维度归一化分数
2. 加权求和得到热门分数
3. 按分数排序返回Top-N

**SQL实现示例**：
```sql
SELECT 
    m.id,
    m.name,
    (m.rating * 0.4 + 
     (m.box_office / (SELECT MAX(box_office) FROM movie WHERE box_office > 0)) * 0.3 +
     (m.view_count / (SELECT MAX(view_count) FROM movie)) * 0.2 +
     (m.favorite_count / (SELECT MAX(favorite_count) FROM movie)) * 0.1) as popularity_score
FROM movie m
WHERE m.status = 'active'
  AND m.rating_count >= 10 -- 至少10人评分
ORDER BY popularity_score DESC
LIMIT 20;
```

### 2.4 实时推荐（Real-Time Recommendation）

**原理**：基于用户最近的行为（浏览、评分、收藏）推荐相关电影

**实现步骤**：
1. 获取用户最近N条行为（如最近7天）
2. 提取行为中的电影ID
3. 基于这些电影，使用内容推荐算法推荐相似电影
4. 应用时间衰减权重（越近的行为权重越高）

**时间衰减公式**：
```
weight(t) = e^(-λ × (current_time - behavior_time))
λ = 0.1 (衰减系数)
```

**SQL实现示例**：
```sql
-- 获取用户最近行为，推荐相关电影
SELECT 
    m2.id as movie_id,
    SUM(EXP(-0.1 * TIMESTAMPDIFF(HOUR, ub.create_time, NOW())) * 1.0) as realtime_score
FROM user_behavior ub
JOIN movie m1 ON m1.id = ub.movie_id
JOIN movie_tag_relation mtr1 ON mtr1.movie_id = m1.id
JOIN movie_tag_relation mtr2 ON mtr2.tag_id = mtr1.tag_id AND mtr2.movie_id != m1.id
JOIN movie m2 ON m2.id = mtr2.movie_id
LEFT JOIN user_behavior ub2 ON ub2.user_id = ub.user_id AND ub2.movie_id = m2.id
WHERE ub.user_id = ?
  AND ub.behavior_type IN ('browse', 'rate', 'favorite')
  AND ub.create_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
  AND ub2.id IS NULL -- 排除已行为过的电影
GROUP BY m2.id
ORDER BY realtime_score DESC
LIMIT 20;
```

## 三、混合推荐融合策略

### 3.1 加权融合

**公式**：
```
final_score(movie) = w1 × CF_score + w2 × Content_score + w3 × Popular_score + w4 × Realtime_score
```

**权重配置**（根据用户类型）：
- **新用户**：Content(0.7) + Popular(0.3)
- **轻度用户**：CF(0.6) + Popular(0.4)
- **重度用户**：CF(0.5) + Realtime(0.3) + Popular(0.2)

### 3.2 去重与多样性保证

1. **去重**：合并推荐结果时，去除重复电影
2. **多样性保证**：
   - 限制同一类型电影数量（最多3部）
   - 限制同一导演电影数量（最多2部）
   - 使用MMR（Maximal Marginal Relevance）算法平衡相关性和多样性

### 3.3 最终推荐列表生成流程

```
1. 用户特征分析 → 确定推荐策略
2. 并行执行多个推荐算法
3. 加权融合各算法结果
4. 去重与多样性调整
5. 过滤已观看/已评分电影
6. 返回Top-N推荐列表
7. 缓存到Redis（过期时间：1小时）
```

## 四、性能优化

### 4.1 缓存策略

**Redis缓存结构**：
```
Key: recommendation:user:{userId}:{type}
Value: JSON数组（电影ID列表）
TTL: 3600秒（1小时）
```

**缓存更新策略**：
- **主动更新**：用户行为后异步更新
- **定时更新**：每日凌晨2点批量更新所有用户推荐
- **被动更新**：缓存过期时重新计算

### 4.2 计算优化

1. **预计算**：
   - 电影相似度矩阵（每日更新）
   - 用户相似度矩阵（每日更新）
   - 热门电影列表（每小时更新）

2. **增量更新**：
   - 只计算新增行为的影响
   - 避免全量重新计算

3. **限制计算范围**：
   - 协同过滤：只计算Top-100相似用户/电影
   - 内容推荐：只计算Top-50相似电影

## 五、冷启动处理

### 5.1 新用户冷启动

**策略**：
1. 注册时收集兴趣标签
2. 基于标签推荐电影
3. 热门推荐兜底

### 5.2 新电影冷启动

**策略**：
1. 基于类型、导演、演员推荐相似电影
2. 热门推荐补充
3. 新上映电影特殊标识

## 六、A/B测试支持

### 6.1 策略配置

```java
public class RecommendationStrategy {
    private String strategyName;  // 策略名称
    private Map<String, Double> weights;  // 各算法权重
    private int userGroup;  // 用户分组（A组/B组）
}
```

### 6.2 效果对比

- 记录每次推荐的策略类型
- 统计点击率、转化率
- 对比不同策略效果

## 七、推荐效果评估指标

### 7.1 准确率（Precision@N）

```
Precision@N = (推荐列表中用户实际感兴趣的电影数) / N
```

### 7.2 召回率（Recall@N）

```
Recall@N = (推荐列表中用户实际感兴趣的电影数) / (用户实际感兴趣的所有电影数)
```

### 7.3 多样性（Diversity）

```
Diversity = 1 - (推荐电影的平均相似度)
```

### 7.4 用户满意度

基于用户对推荐电影的评分反馈：
```
Satisfaction = (用户对推荐电影的平均评分) / 10
```

## 八、实现优先级

### Phase 1（MVP）：基础推荐
1. ✅ 热门推荐
2. ✅ 内容推荐（基于类型）
3. ✅ 实时推荐（简化版）

### Phase 2：协同过滤
1. ✅ 基于用户的协同过滤
2. ✅ 基于物品的协同过滤
3. ✅ 混合融合

### Phase 3：优化
1. ✅ 缓存优化
2. ✅ 性能优化
3. ✅ A/B测试
4. ✅ 效果评估
